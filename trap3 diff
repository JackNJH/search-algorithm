import heapq
from collections import namedtuple

# ------------------------------------------------------------
# 1) Defining the state space
# ------------------------------------------------------------
state_space = {
    (0,0):  [(0,1),(1,0),(1,1)],
    (0,1):  [(0,0),(0,2),(1,1)],
    (0,2):  [(0,1),(0,3),(1,1),(1,2),(1,3)],
    (0,3):  [(0,2),(0,4),(1,3)],
    (0,4):  [(0,3),(0,5),(1,3),(1,4),(1,5)],
    (0,5):  [(0,4),(0,6),(1,5)],
    (0,6):  [(0,5),(0,7),(1,5),(1,6),(1,7)],
    (0,7):  [(0,6),(0,8),(1,7)],
    (0,8):  [(0,7),(0,9),(1,7),(1,8),(1,9)],
    (0,9):  [(0,8),(1,9)],

    (1,0):  [(0,0),(1,1),(2,0),(2,1)],
    (1,1):  [(0,0),(0,1),(0,2),(1,0),(1,2),(2,1)],
    (1,2):  [(0,2),(1,1),(1,3),(2,1),(2,2),(2,3)],
    (1,3):  [(0,2),(0,3),(0,4),(1,2),(1,4),(2,3)],
    (1,4):  [(0,4),(1,3),(1,5),(2,3),(2,4),(2,5)],
    (1,5):  [(0,4),(0,5),(0,6),(1,4),(2,5),(1,6)],
    (1,6):  [(0,6),(1,5),(1,7),(2,5),(2,6),(2,7)],
    (1,7):  [(0,6),(0,7),(0,8),(1,6),(1,8),(2,7)],
    (1,8):  [(0,8),(1,7),(1,9),(2,7),(2,8),(2,9)],
    (1,9):  [(0,8),(0,9),(1,8),(2,9)],

    (2,0):  [(1,0),(2,1),(3,0),(3,1)],
    (2,1):  [(1,0),(1,1),(1,2),(2,0),(2,2),(3,1)],
    (2,2):  [(1,2),(2,1),(2,3),(3,1),(3,2),(3,3)],
    (2,3):  [(1,2),(1,3),(1,4),(2,2),(2,4),(3,3)],
    (2,4):  [(1,4),(2,3),(2,5),(3,3),(3,4),(3,5)],
    (2,5):  [(1,4),(1,5),(1,6),(2,4),(2,6),(3,5)],
    (2,6):  [(1,6),(2,5),(2,7),(3,5),(3,6),(3,7)],
    (2,7):  [(1,6),(1,7),(1,8),(2,6),(2,8),(3,7)],
    (2,8):  [(1,8),(2,7),(2,9),(3,7),(3,8),(3,9)],
    (2,9):  [(1,8),(1,9),(2,8),(3,9)],

    (3,0):  [(2,0),(2,1),(4,0),(4,1)],
    (3,1):  [(2,0),(2,1),(2,2),(3,0),(3,2),(4,1)],
    (3,2):  [(2,2),(3,1),(3,3),(4,1),(4,2),(4,3)],
    (3,3):  [(2,2),(2,3),(2,4),(3,2),(3,4),(4,3)],
    (3,4):  [(2,4),(3,3),(3,5),(4,3),(4,4),(4,5)],
    (3,5):  [(2,4),(2,5),(2,6),(3,4),(3,6),(4,5)],
    (3,6):  [(2,6),(3,5),(3,7),(4,5),(4,6),(4,7)],
    (3,7):  [(2,6),(2,7),(2,8),(3,6),(3,8),(4,7)],
    (3,8):  [(3,7),(2,8),(3,9),(4,9),(4,8),(4,7)],
    (3,9):  [(2,8),(2,9),(3,8),(4,9)],

    (4,0):  [(3,0),(4,1),(5,0),(5,1)],
    (4,1):  [(3,0),(3,1),(3,2),(4,0),(4,2),(5,1)],
    (4,2):  [(3,2),(4,1),(4,3),(5,1),(5,2),(5,3)],
    (4,3):  [(3,2),(3,3),(3,4),(4,2),(4,4),(5,3)],
    (4,4):  [(3,4),(4,3),(4,5),(5,3),(5,4),(5,5)],
    (4,5):  [(3,4),(3,5),(3,6),(4,4),(4,6),(5,5)],
    (4,6):  [(3,6),(4,5),(4,7),(5,5),(5,6),(5,7)],
    (4,7):  [(3,6),(3,7),(3,8),(4,6),(4,8),(5,7)],
    (4,8):  [(3,8),(4,7),(4,9),(5,9),(5,8),(5,7)],
    (4,9):  [(3,8),(3,9),(4,8),(5,9)],

    (5,0):  [(4,0),(5,1)],
    (5,1):  [(4,0),(4,1),(4,2),(5,0),(5,2)],
    (5,2):  [(4,2),(5,1),(5,3)],
    (5,3):  [(4,2),(4,3),(4,4),(5,2),(5,4)],
    (5,4):  [(4,4),(5,3),(5,5)],
    (5,5):  [(4,4),(4,5),(4,6),(5,4),(5,6)],
    (5,6):  [(4,6),(5,5),(5,7)],
    (5,7):  [(4,6),(4,7),(4,8),(5,6),(5,8)],
    (5,8):  [(4,8),(5,7),(5,9)],
    (5,9):  [(4,9),(4,8),(5,8)],
}

def get_neighbors(pos):
    return state_space.get(pos, [])

# ------------------------------------------------------------
# 2) Defining the cell types
# ------------------------------------------------------------
cell_type = {
    (0,0): 'start',    (0,1): 'empty',    (0,2): 'empty',    (0,3): 'empty',    (0,4): 'reward1',
    (0,5): 'empty',    (0,6): 'empty',    (0,7): 'empty',    (0,8): 'empty',    (0,9): 'empty',

    (1,0): 'empty',    (1,1): 'trap2',    (1,2): 'empty',    (1,3): 'trap1',    (1,4): 'treasure',
    (1,5): 'empty',    (1,6): 'trap3',    (1,7): 'empty',    (1,8): 'obstacle', (1,9): 'empty',

    (2,0): 'empty',    (2,1): 'empty',    (2,2): 'obstacle', (2,3): 'empty',    (2,4): 'obstacle',
    (2,5): 'empty',    (2,6): 'empty',    (2,7): 'reward2',  (2,8): 'trap1',    (2,9): 'empty',

    (3,0): 'obstacle', (3,1): 'reward1',  (3,2): 'empty',    (3,3): 'obstacle', (3,4): 'empty',
    (3,5): 'trap3',    (3,6): 'obstacle', (3,7): 'treasure', (3,8): 'empty',    (3,9): 'treasure',

    (4,0): 'empty',    (4,1): 'empty',    (4,2): 'trap2',    (4,3): 'treasure', (4,4): 'obstacle',
    (4,5): 'empty',    (4,6): 'obstacle', (4,7): 'obstacle', (4,8): 'empty',    (4,9): 'empty',

    (5,0): 'empty',    (5,1): 'empty',    (5,2): 'empty',    (5,3): 'empty',    (5,4): 'empty',
    (5,5): 'reward2',  (5,6): 'empty',    (5,7): 'empty',    (5,8): 'empty',    (5,9): 'empty',
}

# ------------------------------------------------------------
# 3. Mapping out the 2D grid
# ------------------------------------------------------------
Cell = namedtuple('Cell', ['type', 'value'])

def make_grid():
    rows, cols = 6, 10
    grid = [[None]*cols for _ in range(rows)]
    start = None
    treasures = set()

    for (r, c), kind in cell_type.items():
        if kind == 'empty':
            grid[r][c] = Cell('empty', None)
        elif kind == 'obstacle':
            grid[r][c] = Cell('obstacle', None)
        elif kind == 'start':
            grid[r][c] = Cell('start', None)
            start = (r, c)
        elif kind == 'treasure':
            grid[r][c] = Cell('treasure', None)
            treasures.add((r, c))
        elif kind == 'trap1':
            grid[r][c] = Cell('trap1', None)
        elif kind == 'trap2':
            grid[r][c] = Cell('trap2', None)
        elif kind == 'trap3':
            grid[r][c] = Cell('trap3', None)
        elif kind == 'trap4':
            grid[r][c] = Cell('trap4', None)
        elif kind == 'reward1':
            grid[r][c] = Cell('reward1', None)
        elif kind == 'reward2':
            grid[r][c] = Cell('reward2', None)
        else:
            raise ValueError(f"Unknown cell code '{kind}' at {(r,c)}")

    if start is None:
        start = (0, 0)
        grid[0][0] = Cell('start', None)

    return grid, start, frozenset(treasures)

# ------------------------------------------------------------
# 4) State class & Search node class
# ------------------------------------------------------------
class State:
    __slots__ = ('pos', 'remaining', 'gravity', 'speed', 'used_rewards', 'used_trap3')

    def __init__(self, pos, remaining, gravity=1.0, speed=1.0,
                 used_rewards=frozenset(), used_trap3=frozenset()):
        self.pos = pos
        self.remaining = remaining
        self.gravity = gravity
        self.speed = speed
        self.used_rewards = used_rewards
        self.used_trap3 = used_trap3

    def __eq__(self, other):
        return (
            isinstance(other, State)
            and self.pos == other.pos
            and self.remaining == other.remaining
            and abs(self.gravity - other.gravity) < 1e-9
            and abs(self.speed - other.speed) < 1e-9
            and self.used_rewards == other.used_rewards
            and self.used_trap3 == other.used_trap3
        )

    def __hash__(self):
        return hash((
            self.pos, self.remaining,
            round(self.gravity, 9), round(self.speed, 9),
            self.used_rewards, self.used_trap3
        ))

    def __repr__(self):
        return (f"State(pos={self.pos}, remaining={len(self.remaining)}, "
                f"gravity={self.gravity:.2f}, speed={self.speed:.2f}, "
                f"used_rewards={list(self.used_rewards)}, "
                f"used_trap3={list(self.used_trap3)})")

class SearchNode:
    __slots__ = ('state', 'cost', 'parent', 'triggered')

    def __init__(self, state, cost, parent=None):
        self.state = state
        self.cost = cost
        self.parent = parent
        self.triggered = None

    def __lt__(self, other):
        return self.cost < other.cost
    
    def __repr__(self):
        return (f"SearchNode(state={self.state}, "
               f"cost={self.cost}, "
               f"parent={self.parent}, "
               f"triggered={self.triggered})")

# ------------------------------------------------------------
# 5) Functions for Trap/Reward/Movement logic
# ------------------------------------------------------------
def step_cost(state):
    return state.gravity * (1.0 / state.speed)

def apply_cell_effect(state, grid):
    r, c = state.pos
    remaining_treasure = set(state.remaining)
    gravity = state.gravity
    speed = state.speed
    used_rewards = set(state.used_rewards)
    used_trap3 = set(state.used_trap3) 
    ctype = grid[r][c].type
    triggered = None

    if ctype == 'treasure' and (r, c) in remaining_treasure:
        remaining_treasure.remove((r, c))
        triggered = ('treasure', (r, c))
    elif ctype == 'trap1':
        gravity *= 2.0
        triggered = ('trap1', (r, c))
    elif ctype == 'trap2':
        speed *= 0.5
        triggered = ('trap2', (r, c))
    elif ctype == 'trap3' and ((r,c) not in used_trap3):
        triggered = ('trap3', (r, c))
    elif ctype == 'trap4':
        triggered = ('trap4', (r, c))
        if remaining_treasure:
            return None, triggered
        remaining_treasure.clear()
    elif ctype == 'reward1' and ((r, c) not in used_rewards):
        gravity *= 0.5
        used_rewards.add((r, c))
        triggered = ('reward1', (r, c))
    elif ctype == 'reward2' and ((r, c) not in used_rewards):
        speed *= 2.0
        used_rewards.add((r, c))
        triggered = ('reward2', (r, c))

    new_state = State(
        pos=(r, c),
        remaining=frozenset(remaining_treasure),
        gravity=gravity,
        speed=speed,
        used_rewards=frozenset(used_rewards),
        used_trap3=frozenset(used_trap3)
    )
    return new_state, triggered

# ------------------------------------------------------------
# 6) Trap3 specific movement mapping
# ------------------------------------------------------------
def get_trap3_push_sequence(from_pos, trap_pos):
    """Get the sequence of positions for trap3 push based on movement direction."""
    # Define the specific trap3 push sequences based on your examples
    trap3_sequences = {
        # For trap3 at (1,6)
        (1,6): {
            (1,5): [(2,7), (2,8)],  # from 1,5 to 1,6 -> push to 2,7 then 2,8
            (0,6): None,            # from 0,6 to 1,6 -> blocked because 3,6 is obstacle
        },
        # For trap3 at (3,5)
        (3,5): {
            (3,4): [(2,6), (2,7)],  # from 3,4 to 3,5 -> push to 2,6 then 2,7
            (4,5): [(2,5), (1,5)],  # from 4,5 to 3,5 -> push to 2,5 then 1,5
        }
    }
    
    if trap_pos in trap3_sequences:
        return trap3_sequences[trap_pos].get(from_pos)
    return None

# ─── Helper for frontier management ─────────────────────────────────────

def push_node(state, cost, triggers, node, explored, frontier):
    """Helper to enqueue if unexplored or better cost."""
    if state not in explored or cost < explored[state]:
        child = SearchNode(state, cost=cost, parent=node)
        child.triggered = triggers.copy() if triggers else []
        heapq.heappush(frontier, child)

# ------------------------------------------------------------
# 7) Search Algorithm with corrected trap-3 logic
# ------------------------------------------------------------
def uniform_cost_search(start_state, grid):
    frontier = []
    heapq.heappush(frontier, SearchNode(start_state, cost=0.0))
    explored = {}

    rows, cols = len(grid), len(grid[0])

    def is_valid_grid_pos(pos):
        rr, cc = pos
        return (0 <= rr < rows and 0 <= cc < cols)

    while frontier:
        node = heapq.heappop(frontier)
        state = node.state
        cost = node.cost

        if state in explored and explored[state] <= cost:
            continue
        explored[state] = cost

        if not state.remaining:
            return node

        (r, c) = state.pos

        for (nr, nc) in get_neighbors((r, c)):
            neighbor_type = grid[nr][nc].type

            if neighbor_type == 'obstacle':
                continue

            # Handle trap3 with specific push sequences
            if neighbor_type == 'trap3' and (nr, nc) not in state.used_trap3:
                push_sequence = get_trap3_push_sequence((r, c), (nr, nc))
                
                # If movement to this trap3 is blocked (returns None)
                if push_sequence is None:
                    continue
                
                # Calculate cost to reach the trap
                move_cost = step_cost(state)
                new_cost = cost + move_cost
                
                # Create state on the trap and mark it as used
                temp_state_landing = State(
                    pos=(nr, nc),
                    remaining=state.remaining,
                    gravity=state.gravity,
                    speed=state.speed,
                    used_rewards=state.used_rewards,
                    used_trap3=state.used_trap3
                )
                
                state_after_landing, triggered_on_landing = apply_cell_effect(temp_state_landing, grid)
                
                if state_after_landing is None:  # trap4 triggered
                    continue
                
                # Mark trap3 as used
                trap_state = State(
                    pos=(nr, nc),
                    remaining=state_after_landing.remaining,
                    gravity=state_after_landing.gravity,
                    speed=state_after_landing.speed,
                    used_rewards=state_after_landing.used_rewards,
                    used_trap3=state_after_landing.used_trap3.union({(nr, nc)})
                )
                
                triggers = [('trap3', (nr, nc))]
                
                # Execute the push sequence
                current_state = trap_state
                current_cost = new_cost
                
                for i, push_pos in enumerate(push_sequence):
                    if not is_valid_grid_pos(push_pos) or grid[push_pos[0]][push_pos[1]].type == 'obstacle':
                        # If we hit an invalid position, stay at current position
                        break
                    
                    # Move to the push position
                    current_cost += step_cost(current_state)
                    
                    # Apply effects of the new position
                    temp_push_state = State(
                        pos=push_pos,
                        remaining=current_state.remaining,
                        gravity=current_state.gravity,
                        speed=current_state.speed,
                        used_rewards=current_state.used_rewards,
                        used_trap3=current_state.used_trap3
                    )
                    
                    state_after_push, triggered_on_push = apply_cell_effect(temp_push_state, grid)
                    
                    if state_after_push is None:  # Hit trap4
                        # Stay at previous position
                        break
                    
                    if triggered_on_push:
                        triggers.append(triggered_on_push)
                    
                    current_state = state_after_push
                
                # Add the final state to the frontier
                push_node(current_state, current_cost, triggers, node, explored, frontier)
                
            else:
                # Normal move (not trap3 or trap3 already used)
                move_cost = step_cost(state)
                new_cost = cost + move_cost

                temp_state_landing = State(
                    pos=(nr, nc),
                    remaining=state.remaining,
                    gravity=state.gravity,
                    speed=state.speed,
                    used_rewards=state.used_rewards,
                    used_trap3=state.used_trap3
                )

                state_after_landing, triggered_on_landing = apply_cell_effect(temp_state_landing, grid)
                
                if state_after_landing is None:  # trap4 triggered
                    continue

                current_path_triggers = []
                if triggered_on_landing:
                    if isinstance(triggered_on_landing, list):
                        current_path_triggers.extend(triggered_on_landing)
                    else:
                        current_path_triggers.append(triggered_on_landing)

                if state_after_landing not in explored or new_cost < explored[state_after_landing]:
                    child = SearchNode(state_after_landing, cost=new_cost, parent=node)
                    child.triggered = current_path_triggers
                    heapq.heappush(frontier, child)

    return None

# ------------------------------------------------------------
# 8) Retracing path + Visuals
# ------------------------------------------------------------
def retrace_path(goal_node):
    path, triggers, costs = [], [], []
    current_node = goal_node
    while current_node is not None:
        path.append(current_node.state.pos)
        triggers.append(current_node.triggered)
        costs.append(current_node.cost)
        current_node = current_node.parent

    path.reverse()
    triggers.reverse()
    costs.reverse()
    return path, triggers, costs

def print_solution(goal_node, grid):
    path, triggers, costs = retrace_path(goal_node)
    
    print("\n--- SOLUTION FOUND ---")
    print(f"Total cost: {goal_node.cost:.3f}")
    print(f"Path length: {len(path)} steps")
    print(f"Final state: {goal_node.state}")

    print("\n--- DETAILED PATH WITH COST VERIFICATION ---")
    for i, pos in enumerate(path):
        r, c = pos
        ctype = grid[r][c].type
        cost = costs[i]
        
        if i == 0:
            print(f"Step {i+1:2d}: {pos} [{ctype:8s}] -- START (cumulative: {cost:.3f})")
        else:
            step_cost_val = costs[i] - costs[i-1]
            trig = triggers[i]
            
            trigger_description = ""
            if trig:
                # Ensure trig is always a list of tuples for consistent processing
                if not isinstance(trig, list):
                    trig = [trig] # Convert single trigger to a list for iteration
                
                trigger_strings = []
                for t in trig:
                    if isinstance(t, tuple) and len(t) == 2:
                        trigger_strings.append(f"{t[0]} at {t[1]}")
                    elif isinstance(t, list): # Handle cases where apply_cell_effect might return a list of triggers
                         trigger_strings.extend([f"{sub_t[0]} at {sub_t[1]}" for sub_t in t if isinstance(sub_t, tuple) and len(sub_t) == 2])

                trigger_description = ", ".join(trigger_strings)

            print(f"Step {i+1:2d}: {pos} [{ctype:8s}] -- {trigger_description} "
                  f"(step: {step_cost_val:.3f}, cumulative: {cost:.3f})")

if __name__ == "__main__":
    grid, start_pos, all_treasures = make_grid()

    print("--- TREASURE HUNT SETUP ---")
    print(f"Grid size: {len(grid)} x {len(grid[0])}")
    print(f"Start position: {start_pos}")
    print(f"Treasures: {sorted(all_treasures)}")
    print(f"Number of treasures: {len(all_treasures)}")

    start_state = State(
        pos=start_pos,
        remaining=all_treasures,
        gravity=1.0,
        speed=1.0,
        used_rewards=frozenset(),
        used_trap3=frozenset()
    )

    print(f"\nStarting state: {start_state}")
    print("\nStarting Uniform-Cost Search...\n")

    goal_node = uniform_cost_search(start_state, grid)

    if goal_node is None:
        print("No solution found.")
    else:
        print_solution(goal_node, grid)
